<!DOCTYPE html>
<html>
  <head>
    <!-- no puede utiliza este odigo po derechos de autor Giovanni Ernesto rodriguez diaz  -->
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pintura 3d Gio</title>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
    <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
    <script src="https://cdn.babylonjs.com/recast.js"></script>
    <script src="https://cdn.babylonjs.com/ammo.js"></script>
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
    <script src="https://cdn.babylonjs.com/cannon.js"></script>
    <script src="https://cdn.babylonjs.com/Oimo.js"></script>
    <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
    <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
    <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

    <style>
      html,
      body {
        overflow: hidden;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
      }

      #renderCanvas {
        width: 100%;
        height: 100%;
        touch-action: none;
      }

      #canvasZone {
        width: 100%;
        height: 100%;
        z-index: -1;
      }

      #idpaneldecontrol2 {
        position: absolute;
        top: 70%;
        left: 1%;

        width: auto;
        height: 80px;
        background-color: rgb(0, 0, 0);
        display: flex;
        flex-direction: column;
        flex-wrap: nowrap;
        justify-content: flex-start;
        align-items: flex-start;
        align-content: center;
      }

      #idpaneldecontrol2 * {
        margin-bottom: 1rem;
      }

      #idclickInputfile {
      }

      .displanenoe {
        display: none;
      }

      .clhover:hover {
        color: rgb(27, 145, 255);
        border: 3px solid rgb(27, 145, 255);
      }

      .clcirlce {
        position: relative;
        width: 20px;
        height: 79px;
        border: 3px solid #c7c7c7;
        border-radius: 50%;
        background-color: #000000b9;
        color: #ffffff;

        display: flex;
        flex-direction: column;
        flex-wrap: nowrap;
        justify-content: center;
        align-items: center;
        align-content: center;

        cursor: pointer;
      }

      .imfMostrar1{
        position: absolute;
        bottom:  0%;
        right: 0%;
        z-index: 1000;
        width: 140px;
        height: 130px;
        background-color: #000000b6;
      }
    </style>
  </head>

  <body>
    <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>

    <div id="idpaneldecontrol2">
      <div
        id="idclickInputfile"
        class="clhover clcirlce"
        onclick="loadInputfilesIDdvv()"
      >
        &#x2681;
      </div>
      <script>
        function loadInputfilesIDdvv() {
          document.getElementById("fileInput").click();
        }
      </script>
      <input
        id="fileInput"
        class="displanenoe"
        type="file"
        accept=".glb, .obj"
      />
      <div
        id="idclickInputTexture"
        class="clhover clcirlce"
        onclick="loadInputfilesIDdvvTexture()"
      >
        &#x268F;
      </div>
      <script>
        function loadInputfilesIDdvvTexture() {
          document.getElementById("textureUploader").click();
        }
      </script>
      <input
        type="file"
        id="textureUploader"
        class="displanenoe"
        accept="image/*"
      />
    </div>
    <img id="idimggiob" class="imfMostrar1" src="" alt="" />
    <script>
  var color4Image = new Image();
var canvasdetexture = null;
var canvasidMask = null;

var laimagneesCombiandases = async (url1, url2) => {
            await loadAndResizeImage(url1, 1024, 1024);
            await loadAndResizeImageMarsk("./brush.png", 1024, 1024);
            var imagendata1 = gettImagendataGio(canvasdetexture);
            var imagendataMask = gettImagendataGio(canvasidMask);

            let combianrimgedata = combineImageData(
              imagendata1,
              imagendataMask
            );
            let context = canvasdetexture.getContext("2d");
            context.putImageData(combianrimgedata, 0, 0);
            color4Image.src = canvasdetexture.toDataURL("image/png");
          };

          
          function loadAndResizeImage(imageUrl, width = 1024, height = 1024) {
            return new Promise((resolve, reject) => {
              if (!canvasdetexture) {
                canvasdetexture = document.createElement("canvas");
              }

              canvasdetexture.id = "canvasdetexture";
              let context = canvasdetexture.getContext("2d");

              if (!context) {
                reject(
                  new Error("No se pudo obtener el contexto 2D del canvas.")
                );
                return;
              }

              canvasdetexture.width = width;
              canvasdetexture.height = height;

              const image = new Image();
              image.crossOrigin = "Anonymous";

              image.onload = function () {
                context.drawImage(image, 0, 0, width, height);
                resolve(canvasdetexture);
                if (idimggiob) {
                  idimggiob.width = width;
                  idimggiob.height = height;
                  idimggiob.src = canvasdetexture.toDataURL("image/png");
                }
              };

              image.onerror = function () {
                reject(new Error("No se pudo cargar la imagen."));
              };

              image.src = imageUrl;
            });
          }

       
          function loadAndResizeImageMarsk(
            imageUrl,
            width = 1024,
            height = 1024
          ) {
            return new Promise((resolve, reject) => {
              if (!canvasidMask) {
                canvasidMask = document.createElement("canvas");
              }

              canvasidMask.id = "idMask";
              let context = canvasidMask.getContext("2d");

              if (!context) {
                reject(
                  new Error("No se pudo obtener el contexto 2D del canvas.")
                );
                return;
              }

              canvasidMask.width = width;
              canvasidMask.height = height;

              const image = new Image();
              image.crossOrigin = "Anonymous";

              image.onload = function () {
                context.drawImage(image, 0, 0, width, height);
                resolve(canvasidMask);
              };

              image.onerror = function () {
                reject(new Error("No se pudo cargar la imagen."));
              };

              image.src = "/brush.png";
            });
          }

          function gettImagendataGio(canvas) {
            let ctx = canvas.getContext("2d");
            return ctx.getImageData(0, 0, canvas.width, canvas.height);
          }


          function combineImageData(imageData1, imageData2) {
            if (
              imageData1.width !== imageData2.width ||
              imageData1.height !== imageData2.height
            ) {
              throw new Error("Las imágenes deben tener el mismo tamaño.");
            }

            const width = imageData1.width;
            const height = imageData1.height;
            const data1 = imageData1.data;
            const data2 = imageData2.data;

            const combinedImageData = new ImageData(width, height);
            const combinedData = combinedImageData.data;

            for (let i = 0; i < data1.length; i += 4) {
              const r1 = data1[i];
              const g1 = data1[i + 1];
              const b1 = data1[i + 2];
              const a1 = data1[i + 3] / 255;

              const r2 = data2[i];
              const g2 = data2[i + 1];
              const b2 = data2[i + 2];
              const a2 = data2[i + 3] / 255;

              combinedData[i] = r1;
              combinedData[i + 1] = g1;
              combinedData[i + 2] = b1;
              combinedData[i + 3] = r2;
            }

            return combinedImageData;
          }


          function createBrushTextureantes    (color) {
            const brushTexture = new BABYLON.DynamicTexture(
              "brushTexture",
              { width: 50, height: 50 },
              scene
            );
            const brushContext = brushTexture.getContext();
            brushContext.fillStyle = color;
            brushContext.fillRect(0, 0, 50, 50);
            for (let i = 0; i < 500; i++) {
              brushContext.fillStyle = `rgba(255,255,255,${
                Math.random() * 0.2
              })`;
              brushContext.beginPath();
              brushContext.arc(
                Math.random() * 50,
                Math.random() * 50,
                Math.random() * 2,
                0,
                Math.PI * 2
              );
              brushContext.fill();
            }
            brushTexture.update();
            return brushTexture;
          }
          function crearimgIni   (color, scene=BABYLON.Engine.LastCreatedScene) {
            let brushTexture = new BABYLON.DynamicTexture(
              "brushTexture",
              { width: 50, height: 50 },
              scene
            );
            console.log(brushTexture,'brushTexture');
            let brushContext = brushTexture.getContext();
            console.log(brushContext,' brushContext');
            brushContext.fillStyle = color;
            brushContext.fillRect(0, 0, 50, 50);
            for (let i = 0; i < 500; i++) {
              brushContext.fillStyle = `rgba(255,255,255,${
                Math.random() * 0.2
              })`;
              brushContext.beginPath();
              brushContext.arc(
                Math.random() * 50,
                Math.random() * 50,
                Math.random() * 2,
                0,
                Math.PI * 2
              );
              brushContext.fill();
            }
            brushTexture.update();
            return brushTexture;
          }


          var brushTextures = null;


          color4Image.onload = function (scene=BABYLON.Engine.LastCreatedScene) {
            console.log(scene,'scene load');
            const color4Texture = new BABYLON.DynamicTexture(
              "color4Texture",
              { width: 50, height: 50 },
              BABYLON.Engine.LastCreatedScene/// scene
            );
            const color4Context = color4Texture.getContext();
            color4Context.drawImage(color4Image, 0, 0, 50, 50);
            color4Texture.update();
            brushTextures.color4 = color4Texture;
          };






       




          //---------------------------



      let brushSize = 50;
      let brushRotation = 0;
      var SceneLoader = BABYLON.SceneLoader;
      var canvas = document.getElementById("renderCanvas");
//------
      var startRenderLoop = function (engine, canvas) {
        engine.runRenderLoop(function () {
          if (sceneToRender && sceneToRender.activeCamera) {
            sceneToRender.render();
          }
        });
      };

      var engine = null;
      var scene = null;
      var sceneToRender = null;
      var createDefaultEngine = function () {
        return new BABYLON.Engine(canvas, true, {
          preserveDrawingBuffer: true,
          stencil: true,
          disableWebGL2Support: false,
        });
      };
      class Playground {
        static async CreateScene(engine) {
          const scene = new BABYLON.Scene(engine);

          brushTextures = {
            color1: crearimgIni("red"),
            color2: crearimgIni("blue"),
            color3: crearimgIni("green"),
            color4: null,
          };

          const hdrTexture = BABYLON.CubeTexture.CreateFromPrefilteredData(
            "textures/environment.dds",
            scene
          );
          const currentSkybox = scene.createDefaultSkybox(hdrTexture, true);

          const cube = BABYLON.MeshBuilder.CreateBox(
            "cube",
            { size: 1 },
            scene
          );

          let textureResolution = 1024;
          let dynamicTexture = new BABYLON.DynamicTexture(
            "dynamic texture",
            { width: textureResolution, height: textureResolution },
            scene
          );
          let textureContext = dynamicTexture.getContext();

          textureContext.fillStyle = "white";
          textureContext.fillRect(0, 0, textureResolution, textureResolution);
          dynamicTexture.update();

          let material = new BABYLON.StandardMaterial("cubeMaterial", scene);
          material.diffuseTexture = dynamicTexture;
          cube.material = material;

         

          const createBrushTexture = function (color, imageUrl = null) {
            return new Promise((resolve) => {
              const brushTexture = new BABYLON.DynamicTexture(
                "brushTexture",
                { width: 50, height: 50 },
                scene
              );
              const brushContext = brushTexture.getContext();

              if (imageUrl) {
                const img = new Image();
                img.onload = function () {
                  brushContext.drawImage(img, 0, 0, 50, 50);
                  brushTexture.update();
                  resolve(brushTexture);
                };
                img.src = imageUrl;
              } else {
                brushContext.fillStyle = color;
                brushContext.fillRect(0, 0, 50, 50);
                for (let i = 0; i < 500; i++) {
                  brushContext.fillStyle = `rgba(255,255,255,${
                    Math.random() * 0.2
                  })`;
                  brushContext.beginPath();
                  brushContext.arc(
                    Math.random() * 50,
                    Math.random() * 50,
                    Math.random() * 2,
                    0,
                    Math.PI * 2
                  );
                  brushContext.fill();
                }
                brushTexture.update();
                resolve(brushTexture);
              }
            });
          };

 

          laimagneesCombiandases  ("apintarB.png", "brush.png");
 
          //color4Image.src = "apintarB.png";

          const textureUploader = document.getElementById("textureUploader");

          textureUploader.addEventListener("change", function (event) {
            const file = event.target.files[0];
            if (file) {
              const reader = new FileReader();

              reader.onload = function (e) {
                laimagneesCombiandases(e.target.result, "./brush.png");
              };

              reader.readAsDataURL(file);
            }
          });

 

          let currentBrush = "color1";

          const paint = function (pointerInfo) {
            const pickResult = scene.pick(scene.pointerX, scene.pointerY);

            if (pickResult.hit && true) {
              const faceUV = pickResult.getTextureCoordinates();
              if (faceUV) {
                const x = Math.floor(faceUV.x * textureResolution);
                const y = Math.floor((1 - faceUV.y) * textureResolution);
                if (brushTextures[currentBrush]) {
                  const brushCanvas =
                    brushTextures[currentBrush].getContext().canvas;
                  const brushImageData = brushTextures[currentBrush]
                    .getContext()
                    .getImageData(0, 0, 50, 50);
                  const cubeImageData = textureContext.getImageData(
                    x - brushSize / 2,
                    y - brushSize / 2,
                    brushSize,
                    brushSize
                  );

                  const centerX = brushSize / 2;
                  const centerY = brushSize / 2;
                  const rad = (brushRotation * Math.PI) / 180;

                  for (let i = 0; i < cubeImageData.data.length; i += 4) {
                    const pixelX = (i / 4) % brushSize;
                    const pixelY = Math.floor(i / 4 / brushSize);

                    const rotatedX =
                      Math.cos(rad) * (pixelX - centerX) -
                      Math.sin(rad) * (pixelY - centerY) +
                      centerX;
                    const rotatedY =
                      Math.sin(rad) * (pixelX - centerX) +
                      Math.cos(rad) * (pixelY - centerY) +
                      centerY;

                    const brushX = Math.floor(rotatedX * (50 / brushSize));
                    const brushY = Math.floor(rotatedY * (50 / brushSize));

                    if (
                      brushX >= 0 &&
                      brushX < 50 &&
                      brushY >= 0 &&
                      brushY < 50
                    ) {
                      const brushIndex = (brushY * 50 + brushX) * 4;

                      const alpha = brushImageData.data[brushIndex + 3] / 255;
                      cubeImageData.data[i] =
                        brushImageData.data[brushIndex] * alpha +
                        cubeImageData.data[i] * (1 - alpha);
                      cubeImageData.data[i + 1] =
                        brushImageData.data[brushIndex + 1] * alpha +
                        cubeImageData.data[i + 1] * (1 - alpha);
                      cubeImageData.data[i + 2] =
                        brushImageData.data[brushIndex + 2] * alpha +
                        cubeImageData.data[i + 2] * (1 - alpha);
                    }
                  }

                  textureContext.putImageData(
                    cubeImageData,
                    x - brushSize / 2,
                    y - brushSize / 2
                  );
                  dynamicTexture.update();
                }
              }
            }
          };

          const paintnunca = function (pointerInfo) {
            const pickResult = scene.pick(scene.pointerX, scene.pointerY);

            if (pickResult.hit) {
              const pickedPoint = pickResult.pickedPoint;
              const mesh = pickResult.pickedMesh;

              const uv = getUVFrom3DPoint(pickedPoint, mesh);

              if (uv) {
                const x = Math.floor(uv.x * textureResolution);
                const y = Math.floor((1 - uv.y) * textureResolution);

                if (brushTextures[currentBrush]) {
                  const brushImageData = brushTextures[currentBrush]
                    .getContext()
                    .getImageData(0, 0, 50, 50);
                  const cubeImageData = textureContext.getImageData(
                    x - brushSize / 2,
                    y - brushSize / 2,
                    brushSize,
                    brushSize
                  );

                  for (let i = 0; i < cubeImageData.data.length; i += 4) {
                    const pixelX = (i / 4) % brushSize;
                    const pixelY = Math.floor(i / 4 / brushSize);

                    const rotatedX =
                      Math.cos((brushRotation * Math.PI) / 180) *
                        (pixelX - brushSize / 2) -
                      Math.sin((brushRotation * Math.PI) / 180) *
                        (pixelY - brushSize / 2) +
                      brushSize / 2;
                    const rotatedY =
                      Math.sin((brushRotation * Math.PI) / 180) *
                        (pixelX - brushSize / 2) +
                      Math.cos((brushRotation * Math.PI) / 180) *
                        (pixelY - brushSize / 2) +
                      brushSize / 2;

                    const brushX = Math.floor(rotatedX * (50 / brushSize));
                    const brushY = Math.floor(rotatedY * (50 / brushSize));

                    if (
                      brushX >= 0 &&
                      brushX < 50 &&
                      brushY >= 0 &&
                      brushY < 50
                    ) {
                      const brushIndex = (brushY * 50 + brushX) * 4;
                      const alpha = brushImageData.data[brushIndex + 3] / 255;

                      cubeImageData.data[i] =
                        brushImageData.data[brushIndex] * alpha +
                        cubeImageData.data[i] * (1 - alpha);
                      cubeImageData.data[i + 1] =
                        brushImageData.data[brushIndex + 1] * alpha +
                        cubeImageData.data[i + 1] * (1 - alpha);
                      cubeImageData.data[i + 2] =
                        brushImageData.data[brushIndex + 2] * alpha +
                        cubeImageData.data[i + 2] * (1 - alpha);
                    }
                  }

                  textureContext.putImageData(
                    cubeImageData,
                    x - brushSize / 2,
                    y - brushSize / 2
                  );
                  dynamicTexture.update();
                }
              }
            }
          };

          function getUVFrom3DPoint(pickedPoint, mesh) {
            const positions = mesh.getVerticesData(
              BABYLON.VertexBuffer.PositionKind
            );
            const uvs = mesh.getVerticesData(BABYLON.VertexBuffer.UVKind);
            const indices = mesh.getIndices();

            if (positions && uvs && indices) {
              const numIndices = indices.length;
              let closestUV = null;
              let minDistance = Number.MAX_VALUE;

              for (let i = 0; i < numIndices; i += 3) {
                const i0 = indices[i];
                const i1 = indices[i + 1];
                const i2 = indices[i + 2];

                const p0 = BABYLON.Vector3.FromArray(positions, i0 * 3);
                const p1 = BABYLON.Vector3.FromArray(positions, i1 * 3);
                const p2 = BABYLON.Vector3.FromArray(positions, i2 * 3);

                const u0 = uvs[i0 * 2];
                const v0 = uvs[i0 * 2 + 1];
                const u1 = uvs[i1 * 2];
                const v1 = uvs[i1 * 2 + 1];
                const u2 = uvs[i2 * 2];
                const v2 = uvs[i2 * 2 + 1];

                const barycentric = getBarycentric(pickedPoint, p0, p1, p2);

                if (barycentric) {
                  const uv = {
                    x:
                      barycentric.x * u0 +
                      barycentric.y * u1 +
                      barycentric.z * u2,
                    y:
                      barycentric.x * v0 +
                      barycentric.y * v1 +
                      barycentric.z * v2,
                  };

                  return uv;
                }
              }
            }
            return { x: 0, y: 0 };
          }

          function getBarycentric(p, a, b, c) {
            const v0 = b.subtract(a);
            const v1 = c.subtract(a);
            const v2 = p.subtract(a);

            const dot00 = BABYLON.Vector3.Dot(v0, v0);
            const dot01 = BABYLON.Vector3.Dot(v0, v1);
            const dot02 = BABYLON.Vector3.Dot(v0, v2);
            const dot11 = BABYLON.Vector3.Dot(v1, v1);
            const dot12 = BABYLON.Vector3.Dot(v1, v2);

            const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
            const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
            const v = (dot00 * dot12 - dot01 * dot02) * invDenom;

            return { x: u, y: v, z: 1 - u - v };
          }

          scene.onPointerObservable.add((pointerInfo) => {
            if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERDOWN) {
              paint(pointerInfo);
            }
          });

          const advancedTexture =
            BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

          const addButton = function (text, color, x) {
            console.log(text, color, x);
            const button = BABYLON.GUI.Button.CreateSimpleButton(
              "button" + text,
              text
            );
            button.width = "100px";
            button.height = "40px";
            button.color = "white";
            button.background = color;
            button.horizontalAlignment =
              BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            button.verticalAlignment =
              BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
            button.left = x;
            button.top = "-10px";
            button.onPointerUpObservable.add(function () {
              currentBrush = "color" + text.slice(-1);
              console.log(currentBrush, "currentBrush");
            });
            advancedTexture.addControl(button);
          };

          addButton("Color 4", "rgba(0, 0, 0, 0.5)", "10px");
           currentBrush='color4';

          const brushSizeSlider = new BABYLON.GUI.Slider();
          brushSizeSlider.minimum = 0;
          brushSizeSlider.maximum = 1000;
          brushSizeSlider.value = 50;
          brushSizeSlider.height = "20px";
          brushSizeSlider.width = "200px";
          brushSizeSlider.horizontalAlignment =
            BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
          brushSizeSlider.verticalAlignment =
            BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
          brushSizeSlider.left = "10px";
          brushSizeSlider.top = "-60px";
          brushSizeSlider.onValueChangedObservable.add(function (value) {
            brushSize = value;
          });
          advancedTexture.addControl(brushSizeSlider);

          const brushSizeText = new BABYLON.GUI.TextBlock();
          brushSizeText.text = "Tamaño de brocha: 50";
          brushSizeText.height = "20px";
          brushSizeText.color = "white";
          brushSizeText.horizontalAlignment =
            BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
          brushSizeText.verticalAlignment =
            BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
          brushSizeText.left = "220px";
          brushSizeText.top = "-60px";
          advancedTexture.addControl(brushSizeText);

          brushSizeSlider.onValueChangedObservable.add(function (value) {
            brushSize = value;
            brushSizeText.text = "Tamaño de brocha: " + Math.round(value);
          });

          const lockRotationCheckbox = new BABYLON.GUI.Checkbox();
          lockRotationCheckbox.width = "20px";
          lockRotationCheckbox.height = "20px";
          lockRotationCheckbox.isChecked = false;
          lockRotationCheckbox.horizontalAlignment =
            BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
          lockRotationCheckbox.verticalAlignment =
            BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
          lockRotationCheckbox.left = "10px";
          lockRotationCheckbox.top = "-90px";
          lockRotationCheckbox.onIsCheckedChangedObservable.add(function (
            value
          ) {
            isRotationLocked = value;
            camera.detachControl(canvas);
            if (!value) {
              camera.attachControl(canvas, true);
            }
          });
          advancedTexture.addControl(lockRotationCheckbox);

          const lockRotationText = new BABYLON.GUI.TextBlock();
          lockRotationText.text = "Bloquear rotación";
          lockRotationText.height = "20px";
          lockRotationText.color = "white";
          lockRotationText.horizontalAlignment =
            BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
          lockRotationText.verticalAlignment =
            BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
          lockRotationText.left = "40px";
          lockRotationText.top = "-90px";
          advancedTexture.addControl(lockRotationText);

          const brushRotationSlider = new BABYLON.GUI.Slider();
          brushRotationSlider.minimum = 0;
          brushRotationSlider.maximum = 360;
          brushRotationSlider.value = 0;
          brushRotationSlider.height = "20px";
          brushRotationSlider.width = "200px";
          brushRotationSlider.horizontalAlignment =
            BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
          brushRotationSlider.verticalAlignment =
            BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
          brushRotationSlider.left = "10px";
          brushRotationSlider.top = "-120px";
          brushRotationSlider.onValueChangedObservable.add(function (value) {
            brushRotation = value;
          });
          advancedTexture.addControl(brushRotationSlider);

          const brushRotationText = new BABYLON.GUI.TextBlock();
          brushRotationText.text = "Rotación de brocha: 0°";
          brushRotationText.height = "20px";
          brushRotationText.color = "white";
          brushRotationText.horizontalAlignment =
            BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
          brushRotationText.verticalAlignment =
            BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
          brushRotationText.left = "220px";
          brushRotationText.top = "-120px";
          advancedTexture.addControl(brushRotationText);

          brushRotationSlider.onValueChangedObservable.add(function (value) {
            brushRotation = value;
            brushRotationText.text =
              "Rotación de brocha: " + Math.round(value) + "°";
          });

           

          
 

          function createPBRMaterial(scene, urlAlbedoTexture) {
            const material = new BABYLON.PBRMaterial("pbrMaterial", scene);
            material.albedoTexture = dynamicTexture.clone();
            material.metallic = 0.5;
            material.roughness = 0.5;

            return material;
          }

          function adjustUVScale(mesh) {
            const uvs = mesh.getVerticesData(BABYLON.VertexBuffer.UVKind);
            if (!uvs) {
              console.warn("No UV data found for the mesh.");
              return;
            }

            let minU = Number.MAX_VALUE,
              maxU = -Number.MAX_VALUE;
            let minV = Number.MAX_VALUE,
              maxV = -Number.MAX_VALUE;

            for (let i = 0; i < uvs.length; i += 2) {
              const u = uvs[i];
              const v = uvs[i + 1];

              if (u < minU) minU = u;
              if (u > maxU) maxU = u;
              if (v < minV) minV = v;
              if (v > maxV) maxV = v;
            }

            const scaleU = maxU - minU;
            const scaleV = maxV - minV;

            console.log(`UV Scale - U: ${scaleU}, V: ${scaleV}`);

            const adjustedUVs = uvs.map((uv, index) => {
              if (index % 2 === 0) {
                return (uv - minU) / scaleU;
              } else {
                return (uv - minV) / scaleV;
              }
            });

            mesh.setVerticesData(BABYLON.VertexBuffer.UVKind, adjustedUVs);

            console.log("UVs adjusted and applied.");
          }

          scene.createDefaultCameraOrLight(true, true, true);
          let camera = null;
          scene.debugLayer.show({ embedMode: true });
          const textureResolution4 = 1024;
          const dynamicTexture3 = new BABYLON.DynamicTexture(
            "dynamic texture",
            { width: textureResolution, height: textureResolution },
            scene
          );
          const textureContext3 = dynamicTexture.getContext();
          const input = document.getElementById("fileInput");

          var loasExternaObj = async (url) => {
            scene.meshes.forEach((mesh) => {
              if (mesh.name !== "hdrSkyBox") {
                mesh.dispose();
              }
            });

            scene.materials.forEach((material) => {
              if (material.name !== "skyBox") {
                material.dispose();
              }
            });

            await BABYLON.SceneLoader.AppendAsync(url, "", scene);

            const image = new Image();
            image.src = "b1.png";
            image.onload = () => {
              let dynamicTexturev = new BABYLON.DynamicTexture(
                "dynamicTexture",
                { width: 1024, height: 1024 },
                scene,
                false
              );
              let ctxv = dynamicTexturev.getContext();
              ctxv.drawImage(image, 0, 0, 1024, 1024);
              dynamicTexturev.update();

              textureResolution = 1024;
              dynamicTexture = new BABYLON.DynamicTexture(
                "dynamic texture",
                { width: textureResolution, height: textureResolution },
                scene
              );
              textureContext = dynamicTexture.getContext();

              textureContext.fillStyle = "white";
              textureContext.fillRect(
                0,
                0,
                textureResolution,
                textureResolution
              );
              dynamicTexture.update();

              material = new BABYLON.StandardMaterial("cubeMaterial", scene);
              material.diffuseTexture = dynamicTexture;

              let pbrMaterial = new BABYLON.PBRMaterial("pbrMaterial", scene);
              pbrMaterial.albedoTexture = dynamicTexturev;
              pbrMaterial.metallic = 0.7;
              pbrMaterial.roughness = 0.2;

              scene.meshes.forEach((mesh) => {
                if (mesh.name !== "hdrSkyBox") {
                  mesh.material = material;
                  adjustUVScale(mesh);
                }
              });
            };
          };

          input.type = "file";
          input.accept = ".glb, .obj";

          input.addEventListener("change", async (e) => {
            if (e.target.files && e.target.files[0]) {
              const reader = new FileReader();
              reader.onload = (e) => {
                loasExternaObj(e.target.result, scene);
              };
              reader.readAsDataURL(e.target.files[0]);
            }
          });
          return scene;
        }
      }

      createScene = function () {
        return Playground.CreateScene(engine, engine.getRenderingCanvas());
      };
      window.initFunction = async function () {
        var asyncEngineCreation = async function () {
          try {
            return createDefaultEngine();
          } catch (e) {
            console.log(
              "the available createEngine function failed. Creating the default engine instead"
            );
            return createDefaultEngine();
          }
        };

        window.engine = await asyncEngineCreation();
        if (!engine) throw "engine should not be null.";
        startRenderLoop(engine, canvas);
        window.scene = createScene();
      };
      initFunction().then(() => {
        scene.then((returnedScene) => {
          sceneToRender = returnedScene;
        });
      });


      window.addEventListener("resize", function () {
        engine.resize();
      });
    </script>
  </body>
</html>
